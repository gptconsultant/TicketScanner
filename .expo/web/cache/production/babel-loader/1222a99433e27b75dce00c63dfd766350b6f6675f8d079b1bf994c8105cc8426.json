{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import{fetchFromAPI}from\"./api\";import*as mockData from\"./mockData\";import{validateRules}from\"./rulesEngine\";import{parseQRData,validateQRFormat}from\"../utils/qrUtils\";import{getCachedTicketById,markCachedTicketAsUsed}from\"./offlineStorage\";export var validateTicket=function(){var _ref=_asyncToGenerator(function*(ticketData,eventId,gateId){try{var formatValidation=validateQRFormat(ticketData);if(!formatValidation.valid){return formatValidation;}return yield mockData.mockValidateTicket(ticketData,eventId,gateId);}catch(error){console.error('Error validating ticket:',error);return{valid:false,reason:error.message||'Error validating ticket'};}});return function validateTicket(_x,_x2,_x3){return _ref.apply(this,arguments);};}();export var validateTicketOffline=function validateTicketOffline(ticket,eventId,gateId,rules){try{var ticketObj;if(typeof ticket==='string'){var formatValidation=validateQRFormat(ticket);if(!formatValidation.valid){return formatValidation;}ticketObj=parseQRData(ticket);}else{ticketObj=ticket;}if(!ticketObj||!ticketObj.id){return{valid:false,reason:'Invalid ticket format',ticket:ticketObj};}if(ticketObj.eventId&&ticketObj.eventId!==eventId){return{valid:false,reason:'Ticket is for a different event',ticket:ticketObj};}var rulesValidation=validateRules(ticketObj,gateId,rules);if(rulesValidation.valid){markCachedTicketAsUsed(ticketObj.id);}return _objectSpread(_objectSpread({},rulesValidation),{},{ticket:ticketObj,offline:true});}catch(error){console.error('Error validating ticket offline:',error);return{valid:false,reason:error.message||'Error validating ticket offline',offline:true};}};export var syncCheckIns=function(){var _ref2=_asyncToGenerator(function*(checkIns){try{return yield mockData.mockSyncCheckIns(checkIns);}catch(error){console.error('Error syncing check-ins:',error);throw error;}});return function syncCheckIns(_x4){return _ref2.apply(this,arguments);};}();export var getTicketHistory=function(){var _ref3=_asyncToGenerator(function*(eventId){try{return[];}catch(error){console.error(`Error getting ticket history for event ${eventId}:`,error);throw error;}});return function getTicketHistory(_x5){return _ref3.apply(this,arguments);};}();","map":{"version":3,"names":["fetchFromAPI","mockData","validateRules","parseQRData","validateQRFormat","getCachedTicketById","markCachedTicketAsUsed","validateTicket","_ref","_asyncToGenerator","ticketData","eventId","gateId","formatValidation","valid","mockValidateTicket","error","console","reason","message","_x","_x2","_x3","apply","arguments","validateTicketOffline","ticket","rules","ticketObj","id","rulesValidation","_objectSpread","offline","syncCheckIns","_ref2","checkIns","mockSyncCheckIns","_x4","getTicketHistory","_ref3","_x5"],"sources":["/home/runner/workspace/src/services/ticketService.js"],"sourcesContent":["import { fetchFromAPI } from './api';\nimport * as mockData from './mockData';\nimport { validateRules } from './rulesEngine';\nimport { parseQRData, validateQRFormat } from '../utils/qrUtils';\nimport { getCachedTicketById, markCachedTicketAsUsed } from './offlineStorage';\n\n/**\n * Validate a ticket against the server\n * @param {string} ticketData - QR code data\n * @param {number} eventId - Event ID\n * @param {number} gateId - Gate ID\n * @returns {Promise<Object>} - Validation result\n */\nexport const validateTicket = async (ticketData, eventId, gateId) => {\n  try {\n    // Validate QR format first\n    const formatValidation = validateQRFormat(ticketData);\n    if (!formatValidation.valid) {\n      return formatValidation;\n    }\n    \n    // In a real app, this would call your backend API\n    // return await fetchFromAPI('/tickets/validate', {\n    //   method: 'POST',\n    //   headers: {\n    //     'Content-Type': 'application/json',\n    //   },\n    //   body: JSON.stringify({\n    //     ticketData,\n    //     eventId,\n    //     gateId,\n    //   }),\n    // });\n    \n    // For demo purposes, use mock implementation\n    return await mockData.mockValidateTicket(ticketData, eventId, gateId);\n  } catch (error) {\n    console.error('Error validating ticket:', error);\n    return { \n      valid: false, \n      reason: error.message || 'Error validating ticket' \n    };\n  }\n};\n\n/**\n * Validate a ticket locally (for offline mode)\n * @param {Object} ticket - Ticket object\n * @param {number} eventId - Event ID\n * @param {number} gateId - Gate ID\n * @param {Array} rules - Array of rule objects\n * @returns {Object} - Validation result\n */\nexport const validateTicketOffline = (ticket, eventId, gateId, rules) => {\n  try {\n    // Parse ticket data if it's a string\n    let ticketObj;\n    if (typeof ticket === 'string') {\n      // Validate QR format first\n      const formatValidation = validateQRFormat(ticket);\n      if (!formatValidation.valid) {\n        return formatValidation;\n      }\n      \n      ticketObj = parseQRData(ticket);\n    } else {\n      ticketObj = ticket;\n    }\n    \n    // Check if ticket exists in offline cache\n    if (!ticketObj || !ticketObj.id) {\n      return { \n        valid: false, \n        reason: 'Invalid ticket format',\n        ticket: ticketObj\n      };\n    }\n    \n    // Check if ticket is for this event\n    if (ticketObj.eventId && ticketObj.eventId !== eventId) {\n      return { \n        valid: false, \n        reason: 'Ticket is for a different event',\n        ticket: ticketObj\n      };\n    }\n    \n    // Apply validation rules\n    const rulesValidation = validateRules(ticketObj, gateId, rules);\n    \n    // If validation passed, mark ticket as used in offline storage\n    if (rulesValidation.valid) {\n      markCachedTicketAsUsed(ticketObj.id);\n    }\n    \n    return {\n      ...rulesValidation,\n      ticket: ticketObj,\n      offline: true\n    };\n  } catch (error) {\n    console.error('Error validating ticket offline:', error);\n    return { \n      valid: false, \n      reason: error.message || 'Error validating ticket offline',\n      offline: true\n    };\n  }\n};\n\n/**\n * Sync offline check-ins with the server\n * @param {Array} checkIns - Array of check-in objects\n * @returns {Promise<Array>} - Array of sync results\n */\nexport const syncCheckIns = async (checkIns) => {\n  try {\n    // In a real app, this would call your backend API\n    // return await fetchFromAPI('/tickets/sync', {\n    //   method: 'POST',\n    //   headers: {\n    //     'Content-Type': 'application/json',\n    //   },\n    //   body: JSON.stringify({ checkIns }),\n    // });\n    \n    // For demo purposes, use mock implementation\n    return await mockData.mockSyncCheckIns(checkIns);\n  } catch (error) {\n    console.error('Error syncing check-ins:', error);\n    throw error;\n  }\n};\n\n/**\n * Get ticket history for a specific event\n * @param {number} eventId - Event ID\n * @returns {Promise<Array>} - Array of ticket check-ins\n */\nexport const getTicketHistory = async (eventId) => {\n  try {\n    // In a real app, this would call your backend API\n    // return await fetchFromAPI(`/events/${eventId}/tickets/history`);\n    \n    // For demo purposes, return an empty array\n    return [];\n  } catch (error) {\n    console.error(`Error getting ticket history for event ${eventId}:`, error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}