{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";export var validateRules=function validateRules(ticket,gateId){var rules=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];if(!rules||rules.length===0){return{valid:true};}var applicableRules=getApplicableRules(rules,gateId);for(var rule of applicableRules){if(!rule.isActive)continue;var validation=validateRule(rule,ticket,gateId);if(!validation.valid){return validation;}}return{valid:true};};var validateRule=function validateRule(rule,ticket,gateId){switch(rule.type){case'TIME_RESTRICTION':return validateTimeRestriction(rule,ticket);case'GATE_RESTRICTION':return validateGateRestriction(rule,ticket,gateId);case'TICKET_TYPE_RESTRICTION':return validateTicketTypeRestriction(rule,ticket);case'ONE_TIME_USE':return validateOneTimeUse(ticket);default:return{valid:true};}};var validateTimeRestriction=function validateTimeRestriction(rule,ticket){var timeRange=rule.value.split('-');if(timeRange.length!==2){return{valid:true};}var _timeRange=_slicedToArray(timeRange,2),startTime=_timeRange[0],endTime=_timeRange[1];var now=new Date();var currentHour=now.getHours();var currentMinute=now.getMinutes();var _startTime$split$map=startTime.split(':').map(Number),_startTime$split$map2=_slicedToArray(_startTime$split$map,2),startHour=_startTime$split$map2[0],startMinute=_startTime$split$map2[1];var _endTime$split$map=endTime.split(':').map(Number),_endTime$split$map2=_slicedToArray(_endTime$split$map,2),endHour=_endTime$split$map2[0],endMinute=_endTime$split$map2[1];var currentTimeInMinutes=currentHour*60+currentMinute;var startTimeInMinutes=startHour*60+startMinute;var endTimeInMinutes=endHour*60+endMinute;if(currentTimeInMinutes<startTimeInMinutes||currentTimeInMinutes>endTimeInMinutes){return{valid:false,reason:`Entry is only allowed between ${startTime} and ${endTime}`,rule:rule};}return{valid:true};};var validateGateRestriction=function validateGateRestriction(rule,ticket,gateId){var allowedGates=rule.value.split(',').map(Number);if(!allowedGates.includes(gateId)){return{valid:false,reason:'This ticket is not valid for this entrance',rule:rule};}return{valid:true};};var validateTicketTypeRestriction=function validateTicketTypeRestriction(rule,ticket){var allowedTypes=rule.value.split(',').map(function(type){return type.trim();});if(!allowedTypes.includes(ticket.type)){return{valid:false,reason:`This entrance is only for ${allowedTypes.join('/')} tickets`,rule:rule};}return{valid:true};};var validateOneTimeUse=function validateOneTimeUse(ticket){if(ticket.used){return{valid:false,reason:'This ticket has already been used',rule:{type:'ONE_TIME_USE',name:'One-time Entry'}};}return{valid:true};};export var getApplicableRules=function getApplicableRules(allRules,gateId){return allRules.filter(function(rule){return(!rule.gateIds||!Array.isArray(rule.gateIds)||rule.gateIds.length===0||rule.gateIds.includes(gateId));});};","map":{"version":3,"names":["validateRules","ticket","gateId","rules","arguments","length","undefined","valid","applicableRules","getApplicableRules","rule","isActive","validation","validateRule","type","validateTimeRestriction","validateGateRestriction","validateTicketTypeRestriction","validateOneTimeUse","timeRange","value","split","_timeRange","_slicedToArray","startTime","endTime","now","Date","currentHour","getHours","currentMinute","getMinutes","_startTime$split$map","map","Number","_startTime$split$map2","startHour","startMinute","_endTime$split$map","_endTime$split$map2","endHour","endMinute","currentTimeInMinutes","startTimeInMinutes","endTimeInMinutes","reason","allowedGates","includes","allowedTypes","trim","join","used","name","allRules","filter","gateIds","Array","isArray"],"sources":["/home/runner/workspace/src/services/rulesEngine.js"],"sourcesContent":["/**\n * Validate a ticket against a set of rules\n * @param {Object} ticket - The ticket to validate\n * @param {number} gateId - The ID of the gate being used\n * @param {Array} rules - Array of rule objects to check against\n * @returns {Object} - Validation result with valid flag and reason if invalid\n */\nexport const validateRules = (ticket, gateId, rules = []) => {\n  // If no rules, consider the ticket valid\n  if (!rules || rules.length === 0) {\n    return { valid: true };\n  }\n  \n  // Get rules that apply to this gate\n  const applicableRules = getApplicableRules(rules, gateId);\n  \n  // Validate against each applicable rule\n  for (const rule of applicableRules) {\n    // Skip inactive rules\n    if (!rule.isActive) continue;\n    \n    // Validate against this rule\n    const validation = validateRule(rule, ticket, gateId);\n    \n    // If any rule fails, return the failure result\n    if (!validation.valid) {\n      return validation;\n    }\n  }\n  \n  // If all rules pass, ticket is valid\n  return { valid: true };\n};\n\n/**\n * Validate a ticket against a specific rule\n * @param {Object} rule - The rule to check\n * @param {Object} ticket - The ticket to validate\n * @param {number} gateId - The ID of the gate being used\n * @returns {Object} - Validation result with valid flag and reason if invalid\n */\nconst validateRule = (rule, ticket, gateId) => {\n  switch (rule.type) {\n    case 'TIME_RESTRICTION':\n      return validateTimeRestriction(rule, ticket);\n      \n    case 'GATE_RESTRICTION':\n      return validateGateRestriction(rule, ticket, gateId);\n      \n    case 'TICKET_TYPE_RESTRICTION':\n      return validateTicketTypeRestriction(rule, ticket);\n      \n    case 'ONE_TIME_USE':\n      return validateOneTimeUse(ticket);\n      \n    default:\n      // Unknown rule type, consider it passed\n      return { valid: true };\n  }\n};\n\n/**\n * Validate a time restriction rule\n * @param {Object} rule - The time restriction rule\n * @param {Object} ticket - The ticket to validate\n * @returns {Object} - Validation result\n */\nconst validateTimeRestriction = (rule, ticket) => {\n  // Extract time range from rule value (format: \"HH:MM-HH:MM\")\n  const timeRange = rule.value.split('-');\n  \n  if (timeRange.length !== 2) {\n    // Invalid time range format, consider it passed\n    return { valid: true };\n  }\n  \n  const [startTime, endTime] = timeRange;\n  \n  // Get current time\n  const now = new Date();\n  const currentHour = now.getHours();\n  const currentMinute = now.getMinutes();\n  \n  // Parse start time\n  const [startHour, startMinute] = startTime.split(':').map(Number);\n  \n  // Parse end time\n  const [endHour, endMinute] = endTime.split(':').map(Number);\n  \n  // Convert to minutes for easier comparison\n  const currentTimeInMinutes = currentHour * 60 + currentMinute;\n  const startTimeInMinutes = startHour * 60 + startMinute;\n  const endTimeInMinutes = endHour * 60 + endMinute;\n  \n  // Check if current time is within range\n  if (currentTimeInMinutes < startTimeInMinutes || currentTimeInMinutes > endTimeInMinutes) {\n    return {\n      valid: false,\n      reason: `Entry is only allowed between ${startTime} and ${endTime}`,\n      rule: rule\n    };\n  }\n  \n  return { valid: true };\n};\n\n/**\n * Validate a gate restriction rule\n * @param {Object} rule - The gate restriction rule\n * @param {Object} ticket - The ticket to validate\n * @param {number} gateId - The ID of the gate being used\n * @returns {Object} - Validation result\n */\nconst validateGateRestriction = (rule, ticket, gateId) => {\n  // Extract allowed gates from rule value (comma-separated gate IDs)\n  const allowedGates = rule.value.split(',').map(Number);\n  \n  if (!allowedGates.includes(gateId)) {\n    return {\n      valid: false,\n      reason: 'This ticket is not valid for this entrance',\n      rule: rule\n    };\n  }\n  \n  return { valid: true };\n};\n\n/**\n * Validate a ticket type restriction rule\n * @param {Object} rule - The ticket type restriction rule\n * @param {Object} ticket - The ticket to validate\n * @returns {Object} - Validation result\n */\nconst validateTicketTypeRestriction = (rule, ticket) => {\n  // Extract allowed ticket types from rule value (comma-separated types)\n  const allowedTypes = rule.value.split(',').map(type => type.trim());\n  \n  if (!allowedTypes.includes(ticket.type)) {\n    return {\n      valid: false,\n      reason: `This entrance is only for ${allowedTypes.join('/')} tickets`,\n      rule: rule\n    };\n  }\n  \n  return { valid: true };\n};\n\n/**\n * Validate a one-time use rule\n * @param {Object} ticket - The ticket to validate\n * @returns {Object} - Validation result\n */\nconst validateOneTimeUse = (ticket) => {\n  // This would normally check if the ticket has been used before\n  // For the mock implementation, we'll just assume it's valid\n  // In a real app, this would check against a database\n  \n  // If the ticket has a \"used\" property and it's true, consider it invalid\n  if (ticket.used) {\n    return {\n      valid: false,\n      reason: 'This ticket has already been used',\n      rule: { type: 'ONE_TIME_USE', name: 'One-time Entry' }\n    };\n  }\n  \n  return { valid: true };\n};\n\n/**\n * Get applicable rules for a specific gate\n * @param {Array} allRules - All rules for the event\n * @param {number} gateId - The gate ID\n * @returns {Array} - Rules that apply to this gate\n */\nexport const getApplicableRules = (allRules, gateId) => {\n  return allRules.filter(rule => \n    // If the rule has gateIds field and it's an array, check if this gate is included\n    !rule.gateIds || \n    !Array.isArray(rule.gateIds) || \n    rule.gateIds.length === 0 || \n    rule.gateIds.includes(gateId)\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}