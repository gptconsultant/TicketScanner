{"ast":null,"code":"export var applyRules = function applyRules(ticket, event, gate) {\n  var allRules = getAllRules();\n  return allRules.map(function (rule) {\n    try {\n      return rule.validate(ticket, event, gate);\n    } catch (error) {\n      console.error(`Error applying rule ${rule.name}:`, error);\n      return {\n        name: rule.name,\n        description: rule.description,\n        passed: false,\n        isCritical: rule.isCritical,\n        failReason: 'Error validating rule',\n        error: error.message\n      };\n    }\n  });\n};\nexport var getOfflineRules = function getOfflineRules() {\n  var allRules = getAllRules();\n  return allRules.filter(function (rule) {\n    return rule.offlineCompatible;\n  });\n};\nexport var getAllRules = function getAllRules() {\n  return [{\n    name: 'event-active',\n    description: 'Event must be active',\n    isCritical: true,\n    offlineCompatible: true,\n    validate: function validate(ticket, event) {\n      var passed = event && event.isActive;\n      return {\n        name: 'event-active',\n        description: 'Event must be active',\n        passed: passed,\n        isCritical: true,\n        failReason: passed ? null : 'This event is no longer active'\n      };\n    }\n  }, {\n    name: 'valid-ticket-type',\n    description: 'Ticket must be of a valid type',\n    isCritical: true,\n    offlineCompatible: true,\n    validate: function validate(ticket) {\n      var _ticket$type;\n      var validTypes = ['standard', 'vip', 'early-bird', 'group', 'comp'];\n      var passed = validTypes.includes((_ticket$type = ticket.type) == null ? void 0 : _ticket$type.toLowerCase());\n      return {\n        name: 'valid-ticket-type',\n        description: 'Ticket must be of a valid type',\n        passed: passed,\n        isCritical: true,\n        failReason: passed ? null : 'Invalid ticket type'\n      };\n    }\n  }, {\n    name: 'not-already-used',\n    description: 'Ticket must not have been already used',\n    isCritical: true,\n    offlineCompatible: false,\n    validate: function validate(ticket) {\n      var passed = !ticket.used;\n      return {\n        name: 'not-already-used',\n        description: 'Ticket must not have been already used',\n        passed: passed,\n        isCritical: true,\n        failReason: passed ? null : 'This ticket has already been used'\n      };\n    }\n  }, {\n    name: 'gate-authorization',\n    description: 'Ticket must be authorized for this gate',\n    isCritical: true,\n    offlineCompatible: true,\n    validate: function validate(ticket, event, gate) {\n      var _ticket$type2, _ticket$type3;\n      if (((_ticket$type2 = ticket.type) == null ? void 0 : _ticket$type2.toLowerCase()) === 'vip') {\n        return {\n          name: 'gate-authorization',\n          description: 'Ticket must be authorized for this gate',\n          passed: true,\n          isCritical: true\n        };\n      }\n      var isStandardTicket = ((_ticket$type3 = ticket.type) == null ? void 0 : _ticket$type3.toLowerCase()) === 'standard';\n      var isStandardGate = !gate.name.toLowerCase().includes('vip');\n      var passed = isStandardTicket ? isStandardGate : true;\n      return {\n        name: 'gate-authorization',\n        description: 'Ticket must be authorized for this gate',\n        passed: passed,\n        isCritical: true,\n        failReason: passed ? null : 'This ticket type is not authorized for this gate'\n      };\n    }\n  }, {\n    name: 'gate-enabled',\n    description: 'Gate must be enabled',\n    isCritical: true,\n    offlineCompatible: true,\n    validate: function validate(ticket, event, gate) {\n      var passed = gate && gate.isEnabled;\n      return {\n        name: 'gate-enabled',\n        description: 'Gate must be enabled',\n        passed: passed,\n        isCritical: true,\n        failReason: passed ? null : 'This gate is currently disabled'\n      };\n    }\n  }, {\n    name: 'time-restriction',\n    description: 'Ticket must be used within allowed time',\n    isCritical: false,\n    offlineCompatible: true,\n    validate: function validate(ticket, event) {\n      var now = new Date();\n      var currentHour = now.getHours();\n      var passed = currentHour < 23;\n      return {\n        name: 'time-restriction',\n        description: 'Ticket must be used within allowed time',\n        passed: passed,\n        isCritical: false,\n        failReason: passed ? null : 'Entry is close to cutoff time (11 PM)'\n      };\n    }\n  }, {\n    name: 'capacity-restriction',\n    description: 'Event must not be at capacity',\n    isCritical: false,\n    offlineCompatible: false,\n    validate: function validate(ticket, event) {\n      return {\n        name: 'capacity-restriction',\n        description: 'Event must not be at capacity',\n        passed: true,\n        isCritical: false\n      };\n    }\n  }];\n};","map":{"version":3,"names":["applyRules","ticket","event","gate","allRules","getAllRules","map","rule","validate","error","console","name","description","passed","isCritical","failReason","message","getOfflineRules","filter","offlineCompatible","isActive","_ticket$type","validTypes","includes","type","toLowerCase","used","_ticket$type2","_ticket$type3","isStandardTicket","isStandardGate","isEnabled","now","Date","currentHour","getHours"],"sources":["/home/runner/workspace/src/services/ruleEngine.js"],"sourcesContent":["/**\n * Rule engine for ticket validation\n * Each rule has:\n * - name: Rule identifier\n * - description: Human readable description\n * - validate: Function that validates the rule\n * - isCritical: Whether failing this rule should invalidate the ticket\n */\n\n/**\n * Apply all validation rules to a ticket\n * @param {object} ticket - The ticket to validate\n * @param {object} event - The event\n * @param {object} gate - The gate where the ticket is being scanned\n * @returns {Array} - Results of all rule validations\n */\nexport const applyRules = (ticket, event, gate) => {\n  const allRules = getAllRules();\n  \n  return allRules.map(rule => {\n    try {\n      return rule.validate(ticket, event, gate);\n    } catch (error) {\n      console.error(`Error applying rule ${rule.name}:`, error);\n      return {\n        name: rule.name,\n        description: rule.description,\n        passed: false,\n        isCritical: rule.isCritical,\n        failReason: 'Error validating rule',\n        error: error.message\n      };\n    }\n  });\n};\n\n/**\n * Get a subset of rules that can be applied offline\n * @returns {Array} - Offline-compatible validation rules\n */\nexport const getOfflineRules = () => {\n  // Return only rules that can be validated offline\n  // (rules that don't require server-side data)\n  const allRules = getAllRules();\n  return allRules.filter(rule => rule.offlineCompatible);\n};\n\n/**\n * Get all validation rules\n * @returns {Array} - All validation rules\n */\nexport const getAllRules = () => {\n  return [\n    // Event active rule\n    {\n      name: 'event-active',\n      description: 'Event must be active',\n      isCritical: true,\n      offlineCompatible: true,\n      validate: (ticket, event) => {\n        const passed = event && event.isActive;\n        return {\n          name: 'event-active',\n          description: 'Event must be active',\n          passed,\n          isCritical: true,\n          failReason: passed ? null : 'This event is no longer active'\n        };\n      }\n    },\n    \n    // Ticket type rule\n    {\n      name: 'valid-ticket-type',\n      description: 'Ticket must be of a valid type',\n      isCritical: true,\n      offlineCompatible: true,\n      validate: (ticket) => {\n        // Check if ticket has a valid type\n        const validTypes = ['standard', 'vip', 'early-bird', 'group', 'comp'];\n        const passed = validTypes.includes(ticket.type?.toLowerCase());\n        \n        return {\n          name: 'valid-ticket-type',\n          description: 'Ticket must be of a valid type',\n          passed,\n          isCritical: true,\n          failReason: passed ? null : 'Invalid ticket type'\n        };\n      }\n    },\n    \n    // Already used rule\n    {\n      name: 'not-already-used',\n      description: 'Ticket must not have been already used',\n      isCritical: true,\n      offlineCompatible: false, // Requires server check\n      validate: (ticket) => {\n        // In a real app, this would check server data\n        // For mock, we'll use the ticket's used property\n        const passed = !ticket.used;\n        \n        return {\n          name: 'not-already-used',\n          description: 'Ticket must not have been already used',\n          passed,\n          isCritical: true,\n          failReason: passed ? null : 'This ticket has already been used'\n        };\n      }\n    },\n    \n    // Gate authorization rule\n    {\n      name: 'gate-authorization',\n      description: 'Ticket must be authorized for this gate',\n      isCritical: true,\n      offlineCompatible: true,\n      validate: (ticket, event, gate) => {\n        // VIP tickets can enter through any gate\n        if (ticket.type?.toLowerCase() === 'vip') {\n          return {\n            name: 'gate-authorization',\n            description: 'Ticket must be authorized for this gate',\n            passed: true,\n            isCritical: true\n          };\n        }\n        \n        // For regular tickets, check if this gate accepts the ticket type\n        // In a real app, this would be more complex logic\n        // For now, assume standard tickets can only use standard gates\n        const isStandardTicket = ticket.type?.toLowerCase() === 'standard';\n        const isStandardGate = !gate.name.toLowerCase().includes('vip');\n        \n        const passed = isStandardTicket ? isStandardGate : true;\n        \n        return {\n          name: 'gate-authorization',\n          description: 'Ticket must be authorized for this gate',\n          passed,\n          isCritical: true,\n          failReason: passed ? null : 'This ticket type is not authorized for this gate'\n        };\n      }\n    },\n    \n    // Gate enabled rule\n    {\n      name: 'gate-enabled',\n      description: 'Gate must be enabled',\n      isCritical: true,\n      offlineCompatible: true,\n      validate: (ticket, event, gate) => {\n        const passed = gate && gate.isEnabled;\n        \n        return {\n          name: 'gate-enabled',\n          description: 'Gate must be enabled',\n          passed,\n          isCritical: true,\n          failReason: passed ? null : 'This gate is currently disabled'\n        };\n      }\n    },\n    \n    // Time restriction rule\n    {\n      name: 'time-restriction',\n      description: 'Ticket must be used within allowed time',\n      isCritical: false, // Warning only\n      offlineCompatible: true,\n      validate: (ticket, event) => {\n        // This is a mock rule for time restrictions\n        // In a real app, this would check against event schedule\n        \n        // Let's pretend the event has a cutoff time\n        const now = new Date();\n        const currentHour = now.getHours();\n        \n        // Example: Event ends at 11 PM\n        const passed = currentHour < 23;\n        \n        return {\n          name: 'time-restriction',\n          description: 'Ticket must be used within allowed time',\n          passed,\n          isCritical: false, // Just a warning\n          failReason: passed ? null : 'Entry is close to cutoff time (11 PM)'\n        };\n      }\n    },\n    \n    // Capacity rule\n    {\n      name: 'capacity-restriction',\n      description: 'Event must not be at capacity',\n      isCritical: false, // Warning only\n      offlineCompatible: false, // Requires server check\n      validate: (ticket, event) => {\n        // This would check against server-tracked capacity\n        // For mock, we'll assume the event is not at capacity\n        \n        return {\n          name: 'capacity-restriction',\n          description: 'Event must not be at capacity',\n          passed: true,\n          isCritical: false\n        };\n      }\n    }\n  ];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}