{"ast":null,"code":"\"use strict\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { getHeaderTitle, Header, SafeAreaProviderCompat, Screen } from '@react-navigation/elements';\nimport { StackActions, useLocale } from '@react-navigation/native';\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport { FadeTransition, ShiftTransition } from \"../TransitionConfigs/TransitionPresets.js\";\nimport { BottomTabBarHeightCallbackContext } from \"../utils/BottomTabBarHeightCallbackContext.js\";\nimport { BottomTabBarHeightContext } from \"../utils/BottomTabBarHeightContext.js\";\nimport { useAnimatedHashMap } from \"../utils/useAnimatedHashMap.js\";\nimport { BottomTabBar, getTabBarHeight } from \"./BottomTabBar.js\";\nimport { MaybeScreen, MaybeScreenContainer } from \"./ScreenFallback.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nvar EPSILON = 1e-5;\nvar STATE_INACTIVE = 0;\nvar STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nvar STATE_ON_TOP = 2;\nvar NAMED_TRANSITIONS_PRESETS = {\n  fade: FadeTransition,\n  shift: ShiftTransition,\n  none: {\n    sceneStyleInterpolator: undefined,\n    transitionSpec: {\n      animation: 'timing',\n      config: {\n        duration: 0\n      }\n    }\n  }\n};\nvar useNativeDriver = Platform.OS !== 'web';\nvar hasAnimation = function hasAnimation(options) {\n  var animation = options.animation,\n    transitionSpec = options.transitionSpec;\n  if (animation) {\n    return animation !== 'none';\n  }\n  return Boolean(transitionSpec);\n};\nvar renderTabBarDefault = function renderTabBarDefault(props) {\n  return _jsx(BottomTabBar, _objectSpread({}, props));\n};\nexport function BottomTabView(props) {\n  var _props$tabBar = props.tabBar,\n    tabBar = _props$tabBar === void 0 ? renderTabBarDefault : _props$tabBar,\n    state = props.state,\n    navigation = props.navigation,\n    descriptors = props.descriptors,\n    safeAreaInsets = props.safeAreaInsets,\n    _props$detachInactive = props.detachInactiveScreens,\n    detachInactiveScreens = _props$detachInactive === void 0 ? Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios' : _props$detachInactive;\n  var focusedRouteKey = state.routes[state.index].key;\n  var _useLocale = useLocale(),\n    direction = _useLocale.direction;\n  var _React$useState = React.useState([focusedRouteKey]),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    loaded = _React$useState2[0],\n    setLoaded = _React$useState2[1];\n  if (!loaded.includes(focusedRouteKey)) {\n    setLoaded([].concat(_toConsumableArray(loaded), [focusedRouteKey]));\n  }\n  var previousRouteKeyRef = React.useRef(focusedRouteKey);\n  var tabAnims = useAnimatedHashMap(state);\n  React.useEffect(function () {\n    var _descriptors$previous;\n    var previousRouteKey = previousRouteKeyRef.current;\n    var popToTopAction;\n    if (previousRouteKey !== focusedRouteKey && (_descriptors$previous = descriptors[previousRouteKey]) != null && _descriptors$previous.options.popToTopOnBlur) {\n      var _prevRoute$state;\n      var prevRoute = state.routes.find(function (route) {\n        return route.key === previousRouteKey;\n      });\n      if ((prevRoute == null ? void 0 : (_prevRoute$state = prevRoute.state) == null ? void 0 : _prevRoute$state.type) === 'stack' && prevRoute.state.key) {\n        popToTopAction = _objectSpread(_objectSpread({}, StackActions.popToTop()), {}, {\n          target: prevRoute.state.key\n        });\n      }\n    }\n    var animateToIndex = function animateToIndex() {\n      if (previousRouteKey !== focusedRouteKey) {\n        navigation.emit({\n          type: 'transitionStart',\n          target: focusedRouteKey\n        });\n      }\n      Animated.parallel(state.routes.map(function (route, index) {\n        var _spec;\n        var options = descriptors[route.key].options;\n        var _options$animation = options.animation,\n          animation = _options$animation === void 0 ? 'none' : _options$animation,\n          _options$transitionSp = options.transitionSpec,\n          transitionSpec = _options$transitionSp === void 0 ? NAMED_TRANSITIONS_PRESETS[animation].transitionSpec : _options$transitionSp;\n        var spec = transitionSpec;\n        if (route.key !== previousRouteKey && route.key !== focusedRouteKey) {\n          spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n        }\n        spec = (_spec = spec) != null ? _spec : NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n        var toValue = index === state.index ? 0 : index >= state.index ? 1 : -1;\n        return Animated[spec.animation](tabAnims[route.key], _objectSpread(_objectSpread({}, spec.config), {}, {\n          toValue: toValue,\n          useNativeDriver: useNativeDriver\n        }));\n      }).filter(Boolean)).start(function (_ref) {\n        var finished = _ref.finished;\n        if (finished && popToTopAction) {\n          navigation.dispatch(popToTopAction);\n        }\n        if (previousRouteKey !== focusedRouteKey) {\n          navigation.emit({\n            type: 'transitionEnd',\n            target: focusedRouteKey\n          });\n        }\n      });\n    };\n    animateToIndex();\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [descriptors, focusedRouteKey, navigation, state.index, state.routes, tabAnims]);\n  var dimensions = SafeAreaProviderCompat.initialMetrics.frame;\n  var _React$useState3 = React.useState(function () {\n      return getTabBarHeight({\n        state: state,\n        descriptors: descriptors,\n        dimensions: dimensions,\n        insets: _objectSpread(_objectSpread({}, SafeAreaProviderCompat.initialMetrics.insets), props.safeAreaInsets),\n        style: descriptors[state.routes[state.index].key].options.tabBarStyle\n      });\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    tabBarHeight = _React$useState4[0],\n    setTabBarHeight = _React$useState4[1];\n  var renderTabBar = function renderTabBar() {\n    return _jsx(SafeAreaInsetsContext.Consumer, {\n      children: function children(insets) {\n        var _ref2, _safeAreaInsets$top, _ref3, _safeAreaInsets$right, _ref4, _safeAreaInsets$botto, _ref5, _safeAreaInsets$left;\n        return tabBar({\n          state: state,\n          descriptors: descriptors,\n          navigation: navigation,\n          insets: {\n            top: (_ref2 = (_safeAreaInsets$top = safeAreaInsets == null ? void 0 : safeAreaInsets.top) != null ? _safeAreaInsets$top : insets == null ? void 0 : insets.top) != null ? _ref2 : 0,\n            right: (_ref3 = (_safeAreaInsets$right = safeAreaInsets == null ? void 0 : safeAreaInsets.right) != null ? _safeAreaInsets$right : insets == null ? void 0 : insets.right) != null ? _ref3 : 0,\n            bottom: (_ref4 = (_safeAreaInsets$botto = safeAreaInsets == null ? void 0 : safeAreaInsets.bottom) != null ? _safeAreaInsets$botto : insets == null ? void 0 : insets.bottom) != null ? _ref4 : 0,\n            left: (_ref5 = (_safeAreaInsets$left = safeAreaInsets == null ? void 0 : safeAreaInsets.left) != null ? _safeAreaInsets$left : insets == null ? void 0 : insets.left) != null ? _ref5 : 0\n          }\n        });\n      }\n    });\n  };\n  var routes = state.routes;\n  var hasTwoStates = !routes.some(function (route) {\n    return hasAnimation(descriptors[route.key].options);\n  });\n  var _descriptors$focusedR = descriptors[focusedRouteKey].options.tabBarPosition,\n    tabBarPosition = _descriptors$focusedR === void 0 ? 'bottom' : _descriptors$focusedR;\n  return _jsxs(SafeAreaProviderCompat, {\n    style: {\n      flexDirection: tabBarPosition === 'left' || tabBarPosition === 'right' ? tabBarPosition === 'left' && direction === 'ltr' || tabBarPosition === 'right' && direction === 'rtl' ? 'row-reverse' : 'row' : 'column'\n    },\n    children: [tabBarPosition === 'top' ? _jsx(BottomTabBarHeightCallbackContext.Provider, {\n      value: setTabBarHeight,\n      children: renderTabBar()\n    }) : null, _jsx(MaybeScreenContainer, {\n      enabled: detachInactiveScreens,\n      hasTwoStates: hasTwoStates,\n      style: styles.screens,\n      children: routes.map(function (route, index) {\n        var _sceneStyleInterpolat;\n        var descriptor = descriptors[route.key];\n        var _descriptor$options = descriptor.options,\n          _descriptor$options$l = _descriptor$options.lazy,\n          lazy = _descriptor$options$l === void 0 ? true : _descriptor$options$l,\n          _descriptor$options$a = _descriptor$options.animation,\n          animation = _descriptor$options$a === void 0 ? 'none' : _descriptor$options$a,\n          _descriptor$options$s = _descriptor$options.sceneStyleInterpolator,\n          sceneStyleInterpolator = _descriptor$options$s === void 0 ? NAMED_TRANSITIONS_PRESETS[animation].sceneStyleInterpolator : _descriptor$options$s;\n        var isFocused = state.index === index;\n        var isPreloaded = state.preloadedRouteKeys.includes(route.key);\n        if (lazy && !loaded.includes(route.key) && !isFocused && !isPreloaded) {\n          return null;\n        }\n        var _descriptor$options2 = descriptor.options,\n          freezeOnBlur = _descriptor$options2.freezeOnBlur,\n          _descriptor$options2$ = _descriptor$options2.header,\n          header = _descriptor$options2$ === void 0 ? function (_ref6) {\n            var layout = _ref6.layout,\n              options = _ref6.options;\n            return _jsx(Header, _objectSpread(_objectSpread({}, options), {}, {\n              layout: layout,\n              title: getHeaderTitle(options, route.name)\n            }));\n          } : _descriptor$options2$,\n          headerShown = _descriptor$options2.headerShown,\n          headerStatusBarHeight = _descriptor$options2.headerStatusBarHeight,\n          headerTransparent = _descriptor$options2.headerTransparent,\n          customSceneStyle = _descriptor$options2.sceneStyle;\n        var _ref7 = (_sceneStyleInterpolat = sceneStyleInterpolator == null ? void 0 : sceneStyleInterpolator({\n            current: {\n              progress: tabAnims[route.key]\n            }\n          })) != null ? _sceneStyleInterpolat : {},\n          sceneStyle = _ref7.sceneStyle;\n        var animationEnabled = hasAnimation(descriptor.options);\n        var activityState = isFocused ? STATE_ON_TOP : animationEnabled ? tabAnims[route.key].interpolate({\n          inputRange: [0, 1 - EPSILON, 1],\n          outputRange: [STATE_TRANSITIONING_OR_BELOW_TOP, STATE_TRANSITIONING_OR_BELOW_TOP, STATE_INACTIVE],\n          extrapolate: 'extend'\n        }) : STATE_INACTIVE;\n        return _jsx(MaybeScreen, {\n          style: [StyleSheet.absoluteFill, {\n            zIndex: isFocused ? 0 : -1\n          }],\n          active: activityState,\n          enabled: detachInactiveScreens,\n          freezeOnBlur: freezeOnBlur,\n          shouldFreeze: activityState === STATE_INACTIVE && !isPreloaded,\n          children: _jsx(BottomTabBarHeightContext.Provider, {\n            value: tabBarPosition === 'bottom' ? tabBarHeight : 0,\n            children: _jsx(Screen, {\n              focused: isFocused,\n              route: descriptor.route,\n              navigation: descriptor.navigation,\n              headerShown: headerShown,\n              headerStatusBarHeight: headerStatusBarHeight,\n              headerTransparent: headerTransparent,\n              header: header({\n                layout: dimensions,\n                route: descriptor.route,\n                navigation: descriptor.navigation,\n                options: descriptor.options\n              }),\n              style: [customSceneStyle, animationEnabled && sceneStyle],\n              children: descriptor.render()\n            })\n          })\n        }, route.key);\n      })\n    }), tabBarPosition !== 'top' ? _jsx(BottomTabBarHeightCallbackContext.Provider, {\n      value: setTabBarHeight,\n      children: renderTabBar()\n    }) : null]\n  });\n}\nvar styles = StyleSheet.create({\n  screens: {\n    flex: 1,\n    overflow: 'hidden'\n  }\n});","map":{"version":3,"names":["getHeaderTitle","Header","SafeAreaProviderCompat","Screen","StackActions","useLocale","React","Animated","Platform","StyleSheet","SafeAreaInsetsContext","FadeTransition","ShiftTransition","BottomTabBarHeightCallbackContext","BottomTabBarHeightContext","useAnimatedHashMap","BottomTabBar","getTabBarHeight","MaybeScreen","MaybeScreenContainer","jsx","_jsx","jsxs","_jsxs","EPSILON","STATE_INACTIVE","STATE_TRANSITIONING_OR_BELOW_TOP","STATE_ON_TOP","NAMED_TRANSITIONS_PRESETS","fade","shift","none","sceneStyleInterpolator","undefined","transitionSpec","animation","config","duration","useNativeDriver","OS","hasAnimation","options","Boolean","renderTabBarDefault","props","_objectSpread","BottomTabView","_props$tabBar","tabBar","state","navigation","descriptors","safeAreaInsets","_props$detachInactive","detachInactiveScreens","focusedRouteKey","routes","index","key","_useLocale","direction","_React$useState","useState","_React$useState2","_slicedToArray","loaded","setLoaded","includes","concat","_toConsumableArray","previousRouteKeyRef","useRef","tabAnims","useEffect","_descriptors$previous","previousRouteKey","current","popToTopAction","popToTopOnBlur","_prevRoute$state","prevRoute","find","route","type","popToTop","target","animateToIndex","emit","parallel","map","_spec","_options$animation","_options$transitionSp","spec","toValue","filter","start","_ref","finished","dispatch","dimensions","initialMetrics","frame","_React$useState3","insets","style","tabBarStyle","_React$useState4","tabBarHeight","setTabBarHeight","renderTabBar","Consumer","children","_ref2","_safeAreaInsets$top","_ref3","_safeAreaInsets$right","_ref4","_safeAreaInsets$botto","_ref5","_safeAreaInsets$left","top","right","bottom","left","hasTwoStates","some","_descriptors$focusedR","tabBarPosition","flexDirection","Provider","value","enabled","styles","screens","_sceneStyleInterpolat","descriptor","_descriptor$options","_descriptor$options$l","lazy","_descriptor$options$a","_descriptor$options$s","isFocused","isPreloaded","preloadedRouteKeys","_descriptor$options2","freezeOnBlur","_descriptor$options2$","header","_ref6","layout","title","name","headerShown","headerStatusBarHeight","headerTransparent","customSceneStyle","sceneStyle","_ref7","progress","animationEnabled","activityState","interpolate","inputRange","outputRange","extrapolate","absoluteFill","zIndex","active","shouldFreeze","focused","render","create","flex","overflow"],"sources":["/home/runner/workspace/node_modules/@react-navigation/bottom-tabs/src/views/BottomTabView.tsx"],"sourcesContent":["import {\n  getHeaderTitle,\n  Header,\n  SafeAreaProviderCompat,\n  Screen,\n} from '@react-navigation/elements';\nimport {\n  type NavigationAction,\n  type ParamListBase,\n  StackActions,\n  type TabNavigationState,\n  useLocale,\n} from '@react-navigation/native';\nimport * as React from 'react';\nimport { Animated, Platform, StyleSheet } from 'react-native';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\n\nimport {\n  FadeTransition,\n  ShiftTransition,\n} from '../TransitionConfigs/TransitionPresets';\nimport type {\n  BottomTabBarProps,\n  BottomTabDescriptorMap,\n  BottomTabHeaderProps,\n  BottomTabNavigationConfig,\n  BottomTabNavigationHelpers,\n  BottomTabNavigationOptions,\n  BottomTabNavigationProp,\n} from '../types';\nimport { BottomTabBarHeightCallbackContext } from '../utils/BottomTabBarHeightCallbackContext';\nimport { BottomTabBarHeightContext } from '../utils/BottomTabBarHeightContext';\nimport { useAnimatedHashMap } from '../utils/useAnimatedHashMap';\nimport { BottomTabBar, getTabBarHeight } from './BottomTabBar';\nimport { MaybeScreen, MaybeScreenContainer } from './ScreenFallback';\n\ntype Props = BottomTabNavigationConfig & {\n  state: TabNavigationState<ParamListBase>;\n  navigation: BottomTabNavigationHelpers;\n  descriptors: BottomTabDescriptorMap;\n};\n\nconst EPSILON = 1e-5;\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\n\nconst NAMED_TRANSITIONS_PRESETS = {\n  fade: FadeTransition,\n  shift: ShiftTransition,\n  none: {\n    sceneStyleInterpolator: undefined,\n    transitionSpec: {\n      animation: 'timing',\n      config: { duration: 0 },\n    },\n  },\n} as const;\n\nconst useNativeDriver = Platform.OS !== 'web';\n\nconst hasAnimation = (options: BottomTabNavigationOptions) => {\n  const { animation, transitionSpec } = options;\n\n  if (animation) {\n    return animation !== 'none';\n  }\n\n  return Boolean(transitionSpec);\n};\n\nconst renderTabBarDefault = (props: BottomTabBarProps) => (\n  <BottomTabBar {...props} />\n);\n\nexport function BottomTabView(props: Props) {\n  const {\n    tabBar = renderTabBarDefault,\n    state,\n    navigation,\n    descriptors,\n    safeAreaInsets,\n    detachInactiveScreens = Platform.OS === 'web' ||\n      Platform.OS === 'android' ||\n      Platform.OS === 'ios',\n  } = props;\n\n  const focusedRouteKey = state.routes[state.index].key;\n\n  const { direction } = useLocale();\n\n  /**\n   * List of loaded tabs, tabs will be loaded when navigated to.\n   */\n  const [loaded, setLoaded] = React.useState([focusedRouteKey]);\n\n  if (!loaded.includes(focusedRouteKey)) {\n    // Set the current tab to be loaded if it was not loaded before\n    setLoaded([...loaded, focusedRouteKey]);\n  }\n\n  const previousRouteKeyRef = React.useRef(focusedRouteKey);\n  const tabAnims = useAnimatedHashMap(state);\n\n  React.useEffect(() => {\n    const previousRouteKey = previousRouteKeyRef.current;\n\n    let popToTopAction: NavigationAction | undefined;\n\n    if (\n      previousRouteKey !== focusedRouteKey &&\n      descriptors[previousRouteKey]?.options.popToTopOnBlur\n    ) {\n      const prevRoute = state.routes.find(\n        (route) => route.key === previousRouteKey\n      );\n\n      if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {\n        popToTopAction = {\n          ...StackActions.popToTop(),\n          target: prevRoute.state.key,\n        };\n      }\n    }\n\n    const animateToIndex = () => {\n      if (previousRouteKey !== focusedRouteKey) {\n        navigation.emit({\n          type: 'transitionStart',\n          target: focusedRouteKey,\n        });\n      }\n\n      Animated.parallel(\n        state.routes\n          .map((route, index) => {\n            const { options } = descriptors[route.key];\n            const {\n              animation = 'none',\n              transitionSpec = NAMED_TRANSITIONS_PRESETS[animation]\n                .transitionSpec,\n            } = options;\n\n            let spec = transitionSpec;\n\n            if (\n              route.key !== previousRouteKey &&\n              route.key !== focusedRouteKey\n            ) {\n              // Don't animate if the screen is not previous one or new one\n              // This will avoid flicker for screens not involved in the transition\n              spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n            }\n\n            spec = spec ?? NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n\n            const toValue =\n              index === state.index ? 0 : index >= state.index ? 1 : -1;\n\n            return Animated[spec.animation](tabAnims[route.key], {\n              ...spec.config,\n              toValue,\n              useNativeDriver,\n            });\n          })\n          .filter(Boolean) as Animated.CompositeAnimation[]\n      ).start(({ finished }) => {\n        if (finished && popToTopAction) {\n          navigation.dispatch(popToTopAction);\n        }\n\n        if (previousRouteKey !== focusedRouteKey) {\n          navigation.emit({\n            type: 'transitionEnd',\n            target: focusedRouteKey,\n          });\n        }\n      });\n    };\n\n    animateToIndex();\n\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [\n    descriptors,\n    focusedRouteKey,\n    navigation,\n    state.index,\n    state.routes,\n    tabAnims,\n  ]);\n\n  const dimensions = SafeAreaProviderCompat.initialMetrics.frame;\n  const [tabBarHeight, setTabBarHeight] = React.useState(() =>\n    getTabBarHeight({\n      state,\n      descriptors,\n      dimensions,\n      insets: {\n        ...SafeAreaProviderCompat.initialMetrics.insets,\n        ...props.safeAreaInsets,\n      },\n      style: descriptors[state.routes[state.index].key].options.tabBarStyle,\n    })\n  );\n\n  const renderTabBar = () => {\n    return (\n      <SafeAreaInsetsContext.Consumer>\n        {(insets) =>\n          tabBar({\n            state: state,\n            descriptors: descriptors,\n            navigation: navigation,\n            insets: {\n              top: safeAreaInsets?.top ?? insets?.top ?? 0,\n              right: safeAreaInsets?.right ?? insets?.right ?? 0,\n              bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,\n              left: safeAreaInsets?.left ?? insets?.left ?? 0,\n            },\n          })\n        }\n      </SafeAreaInsetsContext.Consumer>\n    );\n  };\n\n  const { routes } = state;\n\n  // If there is no animation, we only have 2 states: visible and invisible\n  const hasTwoStates = !routes.some((route) =>\n    hasAnimation(descriptors[route.key].options)\n  );\n\n  const { tabBarPosition = 'bottom' } = descriptors[focusedRouteKey].options;\n\n  return (\n    <SafeAreaProviderCompat\n      style={{\n        flexDirection:\n          tabBarPosition === 'left' || tabBarPosition === 'right'\n            ? (tabBarPosition === 'left' && direction === 'ltr') ||\n              (tabBarPosition === 'right' && direction === 'rtl')\n              ? 'row-reverse'\n              : 'row'\n            : 'column',\n      }}\n    >\n      {tabBarPosition === 'top' ? (\n        <BottomTabBarHeightCallbackContext.Provider value={setTabBarHeight}>\n          {renderTabBar()}\n        </BottomTabBarHeightCallbackContext.Provider>\n      ) : null}\n      <MaybeScreenContainer\n        enabled={detachInactiveScreens}\n        hasTwoStates={hasTwoStates}\n        style={styles.screens}\n      >\n        {routes.map((route, index) => {\n          const descriptor = descriptors[route.key];\n          const {\n            lazy = true,\n            animation = 'none',\n            sceneStyleInterpolator = NAMED_TRANSITIONS_PRESETS[animation]\n              .sceneStyleInterpolator,\n          } = descriptor.options;\n          const isFocused = state.index === index;\n          const isPreloaded = state.preloadedRouteKeys.includes(route.key);\n\n          if (\n            lazy &&\n            !loaded.includes(route.key) &&\n            !isFocused &&\n            !isPreloaded\n          ) {\n            // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded\n            return null;\n          }\n\n          const {\n            freezeOnBlur,\n            header = ({ layout, options }: BottomTabHeaderProps) => (\n              <Header\n                {...options}\n                layout={layout}\n                title={getHeaderTitle(options, route.name)}\n              />\n            ),\n            headerShown,\n            headerStatusBarHeight,\n            headerTransparent,\n            sceneStyle: customSceneStyle,\n          } = descriptor.options;\n\n          const { sceneStyle } =\n            sceneStyleInterpolator?.({\n              current: {\n                progress: tabAnims[route.key],\n              },\n            }) ?? {};\n\n          const animationEnabled = hasAnimation(descriptor.options);\n          const activityState = isFocused\n            ? STATE_ON_TOP // the screen is on top after the transition\n            : animationEnabled // is animation is not enabled, immediately move to inactive state\n              ? tabAnims[route.key].interpolate({\n                  inputRange: [0, 1 - EPSILON, 1],\n                  outputRange: [\n                    STATE_TRANSITIONING_OR_BELOW_TOP, // screen visible during transition\n                    STATE_TRANSITIONING_OR_BELOW_TOP,\n                    STATE_INACTIVE, // the screen is detached after transition\n                  ],\n                  extrapolate: 'extend',\n                })\n              : STATE_INACTIVE;\n\n          return (\n            <MaybeScreen\n              key={route.key}\n              style={[StyleSheet.absoluteFill, { zIndex: isFocused ? 0 : -1 }]}\n              active={activityState}\n              enabled={detachInactiveScreens}\n              freezeOnBlur={freezeOnBlur}\n              shouldFreeze={activityState === STATE_INACTIVE && !isPreloaded}\n            >\n              <BottomTabBarHeightContext.Provider\n                value={tabBarPosition === 'bottom' ? tabBarHeight : 0}\n              >\n                <Screen\n                  focused={isFocused}\n                  route={descriptor.route}\n                  navigation={descriptor.navigation}\n                  headerShown={headerShown}\n                  headerStatusBarHeight={headerStatusBarHeight}\n                  headerTransparent={headerTransparent}\n                  header={header({\n                    layout: dimensions,\n                    route: descriptor.route,\n                    navigation:\n                      descriptor.navigation as BottomTabNavigationProp<ParamListBase>,\n                    options: descriptor.options,\n                  })}\n                  style={[customSceneStyle, animationEnabled && sceneStyle]}\n                >\n                  {descriptor.render()}\n                </Screen>\n              </BottomTabBarHeightContext.Provider>\n            </MaybeScreen>\n          );\n        })}\n      </MaybeScreenContainer>\n      {tabBarPosition !== 'top' ? (\n        <BottomTabBarHeightCallbackContext.Provider value={setTabBarHeight}>\n          {renderTabBar()}\n        </BottomTabBarHeightCallbackContext.Provider>\n      ) : null}\n    </SafeAreaProviderCompat>\n  );\n}\n\nconst styles = StyleSheet.create({\n  screens: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}