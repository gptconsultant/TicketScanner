{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar InternetReachability = _createClass(function InternetReachability(configuration, listener) {\n  var _this = this;\n  _classCallCheck(this, InternetReachability);\n  _defineProperty(this, \"_configuration\", void 0);\n  _defineProperty(this, \"_listener\", void 0);\n  _defineProperty(this, \"_isInternetReachable\", undefined);\n  _defineProperty(this, \"_currentInternetReachabilityCheckHandler\", null);\n  _defineProperty(this, \"_currentTimeoutHandle\", null);\n  _defineProperty(this, \"_setIsInternetReachable\", function (isInternetReachable) {\n    if (_this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n    _this._isInternetReachable = isInternetReachable;\n    _this._listener(_this._isInternetReachable);\n  });\n  _defineProperty(this, \"_setExpectsConnection\", function (expectsConnection) {\n    if (_this._currentInternetReachabilityCheckHandler !== null) {\n      _this._currentInternetReachabilityCheckHandler.cancel();\n      _this._currentInternetReachabilityCheckHandler = null;\n    }\n    if (_this._currentTimeoutHandle !== null) {\n      clearTimeout(_this._currentTimeoutHandle);\n      _this._currentTimeoutHandle = null;\n    }\n    if (expectsConnection && _this._configuration.reachabilityShouldRun()) {\n      if (!_this._isInternetReachable) {\n        _this._setIsInternetReachable(null);\n      }\n      _this._currentInternetReachabilityCheckHandler = _this._checkInternetReachability();\n    } else {\n      _this._setIsInternetReachable(false);\n    }\n  });\n  _defineProperty(this, \"_checkInternetReachability\", function () {\n    var controller = new AbortController();\n    var responsePromise = fetch(_this._configuration.reachabilityUrl, {\n      headers: _this._configuration.reachabilityHeaders,\n      method: _this._configuration.reachabilityMethod,\n      cache: 'no-cache',\n      signal: controller.signal\n    });\n    var timeoutHandle;\n    var timeoutPromise = new Promise(function (_, reject) {\n      timeoutHandle = setTimeout(function () {\n        return reject('timedout');\n      }, _this._configuration.reachabilityRequestTimeout);\n    });\n    var cancel = function cancel() {};\n    var cancelPromise = new Promise(function (_, reject) {\n      cancel = function cancel() {\n        return reject('canceled');\n      };\n    });\n    var promise = Promise.race([responsePromise, timeoutPromise, cancelPromise]).then(function (response) {\n      return _this._configuration.reachabilityTest(response);\n    }).then(function (result) {\n      _this._setIsInternetReachable(result);\n      var nextTimeoutInterval = _this._isInternetReachable ? _this._configuration.reachabilityLongTimeout : _this._configuration.reachabilityShortTimeout;\n      _this._currentTimeoutHandle = setTimeout(_this._checkInternetReachability, nextTimeoutInterval);\n    }).catch(function (error) {\n      if ('canceled' === error) {\n        controller.abort();\n      } else {\n        if ('timedout' === error) {\n          controller.abort();\n        }\n        _this._setIsInternetReachable(false);\n        _this._currentTimeoutHandle = setTimeout(_this._checkInternetReachability, _this._configuration.reachabilityShortTimeout);\n      }\n    }).then(function () {\n      clearTimeout(timeoutHandle);\n    }, function (error) {\n      clearTimeout(timeoutHandle);\n      throw error;\n    });\n    return {\n      promise: promise,\n      cancel: cancel\n    };\n  });\n  _defineProperty(this, \"update\", function (state) {\n    if (typeof state.isInternetReachable === 'boolean' && _this._configuration.useNativeReachability) {\n      _this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      _this._setExpectsConnection(state.isConnected);\n    }\n  });\n  _defineProperty(this, \"currentState\", function () {\n    return _this._isInternetReachable;\n  });\n  _defineProperty(this, \"tearDown\", function () {\n    if (_this._currentInternetReachabilityCheckHandler !== null) {\n      _this._currentInternetReachabilityCheckHandler.cancel();\n      _this._currentInternetReachabilityCheckHandler = null;\n    }\n    if (_this._currentTimeoutHandle !== null) {\n      clearTimeout(_this._currentTimeoutHandle);\n      _this._currentTimeoutHandle = null;\n    }\n  });\n  this._configuration = configuration;\n  this._listener = listener;\n});\nexport { InternetReachability as default };","map":{"version":3,"names":["InternetReachability","_createClass","configuration","listener","_this","_classCallCheck","_defineProperty","undefined","isInternetReachable","_isInternetReachable","_listener","expectsConnection","_currentInternetReachabilityCheckHandler","cancel","_currentTimeoutHandle","clearTimeout","_configuration","reachabilityShouldRun","_setIsInternetReachable","_checkInternetReachability","controller","AbortController","responsePromise","fetch","reachabilityUrl","headers","reachabilityHeaders","method","reachabilityMethod","cache","signal","timeoutHandle","timeoutPromise","Promise","_","reject","setTimeout","reachabilityRequestTimeout","cancelPromise","promise","race","then","response","reachabilityTest","result","nextTimeoutInterval","reachabilityLongTimeout","reachabilityShortTimeout","catch","error","abort","state","useNativeReachability","_setExpectsConnection","isConnected","default"],"sources":["/home/runner/workspace/node_modules/@react-native-community/netinfo/lib/module/internal/internetReachability.ts"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport * as PrivateTypes from './privateTypes';\nimport * as Types from './types';\n\ninterface InternetReachabilityCheckHandler {\n  promise: Promise<void>;\n  cancel: () => void;\n}\n\nexport default class InternetReachability {\n  private _configuration: Types.NetInfoConfiguration;\n  private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;\n  private _isInternetReachable: boolean | null | undefined = undefined;\n  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\n  private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    configuration: Types.NetInfoConfiguration,\n    listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\n  ) {\n    this._configuration = configuration;\n    this._listener = listener;\n  }\n\n  private _setIsInternetReachable = (\n    isInternetReachable: boolean | null,\n  ): void => {\n    if (this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n\n    this._isInternetReachable = isInternetReachable;\n    this._listener(this._isInternetReachable);\n  };\n\n  private _setExpectsConnection = (expectsConnection: boolean | null): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n\n    if (expectsConnection && this._configuration.reachabilityShouldRun()) {\n      // If we expect a connection, start the process for finding if we have one\n      // Set the state to \"null\" if it was previously false\n      if (!this._isInternetReachable) {\n        this._setIsInternetReachable(null);\n      }\n      // Start a network request to check for internet\n      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\n    } else {\n      // If we don't expect a connection or don't run reachability check, just change the state to \"false\"\n      this._setIsInternetReachable(false);\n    }\n  };\n\n  private _checkInternetReachability = (): InternetReachabilityCheckHandler => {\n    const controller = new AbortController();\n\n    const responsePromise = fetch(this._configuration.reachabilityUrl, {\n      headers: this._configuration.reachabilityHeaders,\n      method: this._configuration.reachabilityMethod,\n      cache: 'no-cache',\n      signal: controller.signal,\n    });\n\n    // Create promise that will reject after the request timeout has been reached\n    let timeoutHandle: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<Response>((_, reject): void => {\n      timeoutHandle = setTimeout(\n        (): void => reject('timedout'),\n        this._configuration.reachabilityRequestTimeout,\n      );\n    });\n\n    // Create promise that makes it possible to cancel a pending request through a reject\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    let cancel: () => void = (): void => {};\n    const cancelPromise = new Promise<Response>((_, reject): void => {\n      cancel = (): void => reject('canceled');\n    });\n\n    const promise = Promise.race([\n      responsePromise,\n      timeoutPromise,\n      cancelPromise,\n    ])\n      .then(\n        (response): Promise<boolean> => {\n          return this._configuration.reachabilityTest(response);\n        },\n      )\n      .then(\n        (result): void => {\n          this._setIsInternetReachable(result);\n          const nextTimeoutInterval = this._isInternetReachable\n            ? this._configuration.reachabilityLongTimeout\n            : this._configuration.reachabilityShortTimeout;\n          this._currentTimeoutHandle = setTimeout(\n            this._checkInternetReachability,\n            nextTimeoutInterval,\n          );\n        },\n      )\n      .catch(\n        (error: Error | 'timedout' | 'canceled'): void => {\n          if ('canceled' === error) {\n            controller.abort();\n          } else {\n            if ('timedout' === error) {\n              controller.abort();\n            }\n            \n            this._setIsInternetReachable(false);\n            this._currentTimeoutHandle = setTimeout(\n              this._checkInternetReachability,\n              this._configuration.reachabilityShortTimeout,\n            );\n          }\n        },\n      )\n      // Clear request timeout and propagate any errors\n      .then(\n        (): void => {\n          clearTimeout(timeoutHandle);\n        },\n        (error: Error): void => {\n          clearTimeout(timeoutHandle);\n          throw error;\n        },\n      );\n\n    return {\n      promise,\n      cancel,\n    };\n  };\n\n  public update = (state: PrivateTypes.NetInfoNativeModuleState): void => {\n    if (\n      typeof state.isInternetReachable === 'boolean' &&\n      this._configuration.useNativeReachability\n    ) {\n      this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      this._setExpectsConnection(state.isConnected);\n    }\n  };\n\n  public currentState = (): boolean | null | undefined => {\n    return this._isInternetReachable;\n  };\n\n  public tearDown = (): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}