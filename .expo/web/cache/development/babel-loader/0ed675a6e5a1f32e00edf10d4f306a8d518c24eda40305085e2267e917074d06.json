{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as ticketService from \"./ticketService\";\nimport * as gateService from \"./gateService\";\nexport var syncCheckIns = function () {\n  var _ref = _asyncToGenerator(function* (pendingCheckIns) {\n    yield new Promise(function (resolve) {\n      return setTimeout(resolve, 1500);\n    });\n    try {\n      var results = {\n        successful: [],\n        failed: []\n      };\n      for (var checkIn of pendingCheckIns) {\n        try {\n          yield ticketService.markTicketAsUsed(checkIn.ticketId, checkIn.eventId, checkIn.gateId);\n          results.successful.push(checkIn);\n        } catch (error) {\n          console.error(`Failed to sync check-in ${checkIn.ticketId}:`, error);\n          results.failed.push(_objectSpread(_objectSpread({}, checkIn), {}, {\n            error: error.message\n          }));\n        }\n      }\n      return {\n        success: results.failed.length === 0,\n        synced: results.successful.length,\n        failed: results.failed.length,\n        results: results\n      };\n    } catch (error) {\n      console.error('Error syncing check-ins:', error);\n      throw error;\n    }\n  });\n  return function syncCheckIns(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var syncGateStatusChanges = function () {\n  var _ref2 = _asyncToGenerator(function* (pendingChanges) {\n    yield new Promise(function (resolve) {\n      return setTimeout(resolve, 1200);\n    });\n    try {\n      var results = {\n        successful: [],\n        failed: []\n      };\n      for (var change of pendingChanges) {\n        try {\n          yield gateService.updateGateStatus(change.gateId, change.enabled);\n          results.successful.push(change);\n        } catch (error) {\n          console.error(`Failed to sync gate change ${change.gateId}:`, error);\n          results.failed.push(_objectSpread(_objectSpread({}, change), {}, {\n            error: error.message\n          }));\n        }\n      }\n      return {\n        success: results.failed.length === 0,\n        synced: results.successful.length,\n        failed: results.failed.length,\n        results: results\n      };\n    } catch (error) {\n      console.error('Error syncing gate changes:', error);\n      throw error;\n    }\n  });\n  return function syncGateStatusChanges(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var hasPendingChanges = function hasPendingChanges(pendingCheckIns, pendingGateChanges) {\n  return pendingCheckIns && pendingCheckIns.length > 0 || pendingGateChanges && pendingGateChanges.length > 0;\n};","map":{"version":3,"names":["ticketService","gateService","syncCheckIns","_ref","_asyncToGenerator","pendingCheckIns","Promise","resolve","setTimeout","results","successful","failed","checkIn","markTicketAsUsed","ticketId","eventId","gateId","push","error","console","_objectSpread","message","success","length","synced","_x","apply","arguments","syncGateStatusChanges","_ref2","pendingChanges","change","updateGateStatus","enabled","_x2","hasPendingChanges","pendingGateChanges"],"sources":["/home/runner/workspace/src/services/syncService.js"],"sourcesContent":["import * as ticketService from './ticketService';\nimport * as gateService from './gateService';\n\n/**\n * Syncs pending check-ins with the server\n * @param {Array} pendingCheckIns - Array of pending check-ins to sync\n * @returns {Promise<object>} - Result of sync operation\n */\nexport const syncCheckIns = async (pendingCheckIns) => {\n  // Simulate network request\n  await new Promise(resolve => setTimeout(resolve, 1500));\n  \n  try {\n    const results = {\n      successful: [],\n      failed: []\n    };\n    \n    // Process each check-in\n    for (const checkIn of pendingCheckIns) {\n      try {\n        // In a real implementation, this would submit each check-in to the server\n        await ticketService.markTicketAsUsed(\n          checkIn.ticketId, \n          checkIn.eventId, \n          checkIn.gateId\n        );\n        \n        results.successful.push(checkIn);\n      } catch (error) {\n        console.error(`Failed to sync check-in ${checkIn.ticketId}:`, error);\n        results.failed.push({\n          ...checkIn,\n          error: error.message\n        });\n      }\n    }\n    \n    return {\n      success: results.failed.length === 0,\n      synced: results.successful.length,\n      failed: results.failed.length,\n      results\n    };\n  } catch (error) {\n    console.error('Error syncing check-ins:', error);\n    throw error;\n  }\n};\n\n/**\n * Syncs pending gate status changes with the server\n * @param {Array} pendingChanges - Array of pending gate status changes\n * @returns {Promise<object>} - Result of sync operation\n */\nexport const syncGateStatusChanges = async (pendingChanges) => {\n  // Simulate network request\n  await new Promise(resolve => setTimeout(resolve, 1200));\n  \n  try {\n    const results = {\n      successful: [],\n      failed: []\n    };\n    \n    // Process each gate status change\n    for (const change of pendingChanges) {\n      try {\n        // In a real implementation, this would submit each gate status change to the server\n        await gateService.updateGateStatus(\n          change.gateId,\n          change.enabled\n        );\n        \n        results.successful.push(change);\n      } catch (error) {\n        console.error(`Failed to sync gate change ${change.gateId}:`, error);\n        results.failed.push({\n          ...change,\n          error: error.message\n        });\n      }\n    }\n    \n    return {\n      success: results.failed.length === 0,\n      synced: results.successful.length,\n      failed: results.failed.length,\n      results\n    };\n  } catch (error) {\n    console.error('Error syncing gate changes:', error);\n    throw error;\n  }\n};\n\n/**\n * Checks if there are changes waiting to be synced\n * @param {Array} pendingCheckIns - Array of pending check-ins\n * @param {Array} pendingGateChanges - Array of pending gate changes\n * @returns {boolean} - True if there are pending changes\n */\nexport const hasPendingChanges = (pendingCheckIns, pendingGateChanges) => {\n  return (pendingCheckIns && pendingCheckIns.length > 0) || \n         (pendingGateChanges && pendingGateChanges.length > 0);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}