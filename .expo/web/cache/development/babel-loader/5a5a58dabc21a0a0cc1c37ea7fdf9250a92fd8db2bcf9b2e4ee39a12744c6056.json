{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"facing\", \"poster\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { CodedError } from 'expo-modules-core';\nimport { forwardRef, useRef, useMemo, useImperativeHandle } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport CameraManager from \"./ExpoCameraManager.web\";\nimport { capture } from \"./web/WebCameraUtils\";\nimport { PictureSizes } from \"./web/WebConstants\";\nimport { useWebCameraStream } from \"./web/useWebCameraStream\";\nimport { useWebQRScanner } from \"./web/useWebQRScanner\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nvar ExponentCamera = forwardRef(function (_ref, ref) {\n  var _props$barcodeScanner3;\n  var facing = _ref.facing,\n    poster = _ref.poster,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var video = useRef(null);\n  var native = useWebCameraStream(video, facing, props, {\n    onCameraReady: function onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  var isQRScannerEnabled = useMemo(function () {\n    var _props$barcodeScanner, _props$barcodeScanner2;\n    return Boolean(((_props$barcodeScanner = props.barcodeScannerSettings) == null ? void 0 : (_props$barcodeScanner2 = _props$barcodeScanner.barcodeTypes) == null ? void 0 : _props$barcodeScanner2.includes('qr')) && !!props.onBarcodeScanned);\n  }, [(_props$barcodeScanner3 = props.barcodeScannerSettings) == null ? void 0 : _props$barcodeScanner3.barcodeTypes, props.onBarcodeScanned]);\n  useWebQRScanner(video, {\n    interval: 300,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === 'front'\n    },\n    onScanned: function onScanned(event) {\n      if (props.onBarcodeScanned) {\n        props.onBarcodeScanned(event);\n      }\n    }\n  });\n  useImperativeHandle(ref, function () {\n    return {\n      getAvailablePictureSizes: function () {\n        var _getAvailablePictureSizes = _asyncToGenerator(function* () {\n          return PictureSizes;\n        });\n        function getAvailablePictureSizes() {\n          return _getAvailablePictureSizes.apply(this, arguments);\n        }\n        return getAvailablePictureSizes;\n      }(),\n      takePicture: function () {\n        var _takePicture = _asyncToGenerator(function* (options) {\n          var _video$current, _video$current2;\n          if (!video.current || ((_video$current = video.current) == null ? void 0 : _video$current.readyState) !== ((_video$current2 = video.current) == null ? void 0 : _video$current2.HAVE_ENOUGH_DATA)) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n          }\n          var settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n          return capture(video.current, settings, _objectSpread(_objectSpread({}, options), {}, {\n            onPictureSaved: function onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({\n                  nativeEvent: {\n                    data: picture,\n                    id: -1\n                  }\n                });\n              }\n            }\n          }));\n        });\n        function takePicture(_x) {\n          return _takePicture.apply(this, arguments);\n        }\n        return takePicture;\n      }(),\n      resumePreview: function () {\n        var _resumePreview = _asyncToGenerator(function* () {\n          if (video.current) {\n            video.current.play();\n          }\n        });\n        function resumePreview() {\n          return _resumePreview.apply(this, arguments);\n        }\n        return resumePreview;\n      }(),\n      pausePreview: function () {\n        var _pausePreview = _asyncToGenerator(function* () {\n          if (video.current) {\n            video.current.pause();\n          }\n        });\n        function pausePreview() {\n          return _pausePreview.apply(this, arguments);\n        }\n        return pausePreview;\n      }()\n    };\n  }, [native.mediaTrackSettings, props.onPictureSaved]);\n  var isMuted = true;\n  var style = useMemo(function () {\n    var isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return _jsxs(View, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style],\n    children: [_jsx(Video, {\n      autoPlay: true,\n      playsInline: true,\n      muted: isMuted,\n      poster: poster,\n      pointerEvents: props.pointerEvents,\n      ref: video,\n      style: style\n    }), props.children]\n  });\n});\nexport default ExponentCamera;\nvar Video = forwardRef(function (props, ref) {\n  return createElement('video', _objectSpread(_objectSpread({}, props), {}, {\n    ref: ref\n  }));\n});\nvar styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"names":["CodedError","forwardRef","useRef","useMemo","useImperativeHandle","StyleSheet","View","createElement","CameraManager","capture","PictureSizes","useWebCameraStream","useWebQRScanner","jsx","_jsx","jsxs","_jsxs","ExponentCamera","_ref","ref","_props$barcodeScanner3","facing","poster","props","_objectWithoutProperties","_excluded","video","native","onCameraReady","onMountError","isQRScannerEnabled","_props$barcodeScanner","_props$barcodeScanner2","Boolean","barcodeScannerSettings","barcodeTypes","includes","onBarcodeScanned","interval","isEnabled","captureOptions","scale","isImageMirror","type","onScanned","event","getAvailablePictureSizes","_getAvailablePictureSizes","_asyncToGenerator","apply","arguments","takePicture","_takePicture","options","_video$current","_video$current2","current","readyState","HAVE_ENOUGH_DATA","settings","mediaTrackSettings","_objectSpread","onPictureSaved","picture","nativeEvent","data","id","_x","resumePreview","_resumePreview","play","pausePreview","_pausePreview","pause","isMuted","style","isFrontFacingCamera","Type","front","absoluteFill","styles","transform","scaleX","undefined","pointerEvents","videoWrapper","children","Video","autoPlay","playsInline","muted","create","flex","alignItems","width","height","objectFit"],"sources":["/home/runner/workspace/node_modules/expo-camera/src/ExpoCamera.web.tsx"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\nimport {\n  type PropsWithChildren,\n  forwardRef,\n  useRef,\n  useMemo,\n  useImperativeHandle,\n  type ComponentProps,\n  type Ref,\n} from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraNativeProps,\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExpoCameraManager.web';\nimport { capture } from './web/WebCameraUtils';\nimport { PictureSizes } from './web/WebConstants';\nimport { useWebCameraStream } from './web/useWebCameraStream';\nimport { useWebQRScanner } from './web/useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = forwardRef(\n  (\n    { facing, poster, ...props }: PropsWithChildren<CameraNativeProps>,\n    ref: Ref<ExponentCameraRef>\n  ) => {\n    const video = useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, facing as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = useMemo<boolean>(() => {\n      return Boolean(\n        props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned\n      );\n    }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: 300,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === 'front' },\n      onScanned(event) {\n        if (props.onBarcodeScanned) {\n          props.onBarcodeScanned(event);\n        }\n      },\n    });\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = forwardRef(\n  (\n    props: ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}