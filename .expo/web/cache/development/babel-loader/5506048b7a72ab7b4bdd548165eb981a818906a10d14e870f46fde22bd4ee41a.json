{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as ruleEngine from \"./ruleEngine\";\nimport * as mockData from \"./mockData\";\nexport var validateTicket = function () {\n  var _ref = _asyncToGenerator(function* (ticketId, eventId, gateId) {\n    yield new Promise(function (resolve) {\n      return setTimeout(resolve, 1500);\n    });\n    try {\n      var mockTickets = mockData.getTickets();\n      var mockEvent = mockData.getEventById(eventId);\n      var mockGate = mockData.getGateById(gateId);\n      var ticket = mockTickets.find(function (t) {\n        return t.id === ticketId;\n      });\n      if (!ticket) {\n        return {\n          isValid: false,\n          message: 'Ticket not found',\n          errorType: 'error',\n          details: 'This ticket ID does not exist in our system'\n        };\n      }\n      if (ticket.eventId !== eventId) {\n        return {\n          isValid: false,\n          message: 'Ticket is for a different event',\n          errorType: 'error',\n          details: 'This ticket is not valid for the selected event'\n        };\n      }\n      var ruleResults = ruleEngine.applyRules(ticket, mockEvent, mockGate);\n      var criticalFailure = ruleResults.find(function (r) {\n        return !r.passed && r.isCritical;\n      });\n      if (criticalFailure) {\n        return {\n          isValid: false,\n          message: criticalFailure.failReason || 'Ticket validation failed',\n          errorType: 'error',\n          details: criticalFailure.description,\n          appliedRules: ruleResults\n        };\n      }\n      var warnings = ruleResults.filter(function (r) {\n        return !r.passed && !r.isCritical;\n      });\n      if (warnings.length > 0) {\n        return {\n          isValid: true,\n          message: 'Ticket valid with warnings',\n          errorType: 'warning',\n          details: warnings[0].failReason,\n          appliedRules: ruleResults\n        };\n      }\n      return {\n        isValid: true,\n        message: 'Ticket is valid',\n        ticketInfo: ticket,\n        appliedRules: ruleResults\n      };\n    } catch (error) {\n      console.error('Ticket validation error:', error);\n      return {\n        isValid: false,\n        message: 'Error validating ticket',\n        errorType: 'error',\n        details: error.message\n      };\n    }\n  });\n  return function validateTicket(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var validateTicketOffline = function () {\n  var _ref2 = _asyncToGenerator(function* (ticketInfo, eventId, gateId) {\n    yield new Promise(function (resolve) {\n      return setTimeout(resolve, 800);\n    });\n    try {\n      var mockEvent = mockData.getEventById(eventId);\n      var mockGate = mockData.getGateById(gateId);\n      if (!ticketInfo.id) {\n        return {\n          isValid: false,\n          message: 'Invalid ticket format',\n          errorType: 'error',\n          details: 'The scanned QR code does not contain valid ticket data'\n        };\n      }\n      if (ticketInfo.eventId !== eventId) {\n        return {\n          isValid: false,\n          message: 'Ticket is for a different event',\n          errorType: 'error',\n          details: 'This ticket is not valid for the selected event'\n        };\n      }\n      var offlineRules = ruleEngine.getOfflineRules();\n      var ruleResults = offlineRules.map(function (rule) {\n        return rule.validate(ticketInfo, mockEvent, mockGate);\n      });\n      var criticalFailure = ruleResults.find(function (r) {\n        return !r.passed && r.isCritical;\n      });\n      if (criticalFailure) {\n        return {\n          isValid: false,\n          message: criticalFailure.failReason || 'Ticket validation failed',\n          errorType: 'error',\n          details: criticalFailure.description,\n          appliedRules: ruleResults\n        };\n      }\n      return {\n        isValid: true,\n        message: 'Ticket appears valid (offline)',\n        errorType: 'warning',\n        details: 'Limited validation in offline mode. Ticket will be fully validated when connection is restored.',\n        appliedRules: ruleResults\n      };\n    } catch (error) {\n      console.error('Offline ticket validation error:', error);\n      return {\n        isValid: false,\n        message: 'Error validating ticket',\n        errorType: 'error',\n        details: error.message\n      };\n    }\n  });\n  return function validateTicketOffline(_x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var markTicketAsUsed = function () {\n  var _ref3 = _asyncToGenerator(function* (ticketId, eventId, gateId) {\n    yield new Promise(function (resolve) {\n      return setTimeout(resolve, 800);\n    });\n    return {\n      success: true,\n      timestamp: new Date().toISOString()\n    };\n  });\n  return function markTicketAsUsed(_x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["ruleEngine","mockData","validateTicket","_ref","_asyncToGenerator","ticketId","eventId","gateId","Promise","resolve","setTimeout","mockTickets","getTickets","mockEvent","getEventById","mockGate","getGateById","ticket","find","t","id","isValid","message","errorType","details","ruleResults","applyRules","criticalFailure","r","passed","isCritical","failReason","description","appliedRules","warnings","filter","length","ticketInfo","error","console","_x","_x2","_x3","apply","arguments","validateTicketOffline","_ref2","offlineRules","getOfflineRules","map","rule","validate","_x4","_x5","_x6","markTicketAsUsed","_ref3","success","timestamp","Date","toISOString","_x7","_x8","_x9"],"sources":["/home/runner/workspace/src/services/ticketService.js"],"sourcesContent":["import * as ruleEngine from './ruleEngine';\nimport * as mockData from './mockData';\n\n/**\n * Validates a ticket against the server\n * @param {string} ticketId - The ticket ID\n * @param {string} eventId - The event ID\n * @param {string} gateId - The gate ID\n * @returns {Promise<object>} - Validation result\n */\nexport const validateTicket = async (ticketId, eventId, gateId) => {\n  // Simulate network request\n  await new Promise(resolve => setTimeout(resolve, 1500));\n  \n  try {\n    // Get mock ticket data - in a real app this would be a server request\n    const mockTickets = mockData.getTickets();\n    const mockEvent = mockData.getEventById(eventId);\n    const mockGate = mockData.getGateById(gateId);\n    \n    const ticket = mockTickets.find(t => t.id === ticketId);\n    \n    if (!ticket) {\n      return {\n        isValid: false,\n        message: 'Ticket not found',\n        errorType: 'error',\n        details: 'This ticket ID does not exist in our system'\n      };\n    }\n    \n    if (ticket.eventId !== eventId) {\n      return {\n        isValid: false,\n        message: 'Ticket is for a different event',\n        errorType: 'error',\n        details: 'This ticket is not valid for the selected event'\n      };\n    }\n    \n    // Apply validation rules\n    const ruleResults = ruleEngine.applyRules(ticket, mockEvent, mockGate);\n    \n    // Check if any rule failed that should invalidate the ticket\n    const criticalFailure = ruleResults.find(r => !r.passed && r.isCritical);\n    \n    if (criticalFailure) {\n      return {\n        isValid: false,\n        message: criticalFailure.failReason || 'Ticket validation failed',\n        errorType: 'error',\n        details: criticalFailure.description,\n        appliedRules: ruleResults\n      };\n    }\n    \n    // Check if any non-critical warnings exist\n    const warnings = ruleResults.filter(r => !r.passed && !r.isCritical);\n    \n    if (warnings.length > 0) {\n      return {\n        isValid: true,\n        message: 'Ticket valid with warnings',\n        errorType: 'warning',\n        details: warnings[0].failReason,\n        appliedRules: ruleResults\n      };\n    }\n    \n    // If we get here, the ticket is fully valid\n    return {\n      isValid: true,\n      message: 'Ticket is valid',\n      ticketInfo: ticket,\n      appliedRules: ruleResults\n    };\n    \n  } catch (error) {\n    console.error('Ticket validation error:', error);\n    return {\n      isValid: false,\n      message: 'Error validating ticket',\n      errorType: 'error',\n      details: error.message\n    };\n  }\n};\n\n/**\n * Validates a ticket offline (local validation without server)\n * @param {object} ticketInfo - The parsed ticket data from QR\n * @param {string} eventId - The event ID\n * @param {string} gateId - The gate ID \n * @returns {Promise<object>} - Validation result\n */\nexport const validateTicketOffline = async (ticketInfo, eventId, gateId) => {\n  // Add a slight delay to simulate processing\n  await new Promise(resolve => setTimeout(resolve, 800));\n  \n  try {\n    // For offline mode, we can only do basic validation\n    // For a real app, you would use cached event/ticket data\n    \n    const mockEvent = mockData.getEventById(eventId);\n    const mockGate = mockData.getGateById(gateId);\n    \n    // Basic checks\n    if (!ticketInfo.id) {\n      return {\n        isValid: false,\n        message: 'Invalid ticket format',\n        errorType: 'error',\n        details: 'The scanned QR code does not contain valid ticket data'\n      };\n    }\n    \n    if (ticketInfo.eventId !== eventId) {\n      return {\n        isValid: false,\n        message: 'Ticket is for a different event',\n        errorType: 'error',\n        details: 'This ticket is not valid for the selected event'\n      };\n    }\n    \n    // Apply offline validation rules - a subset of the full rules\n    const offlineRules = ruleEngine.getOfflineRules();\n    const ruleResults = offlineRules.map(rule => rule.validate(ticketInfo, mockEvent, mockGate));\n    \n    // Check if any critical rule failed\n    const criticalFailure = ruleResults.find(r => !r.passed && r.isCritical);\n    \n    if (criticalFailure) {\n      return {\n        isValid: false,\n        message: criticalFailure.failReason || 'Ticket validation failed',\n        errorType: 'error',\n        details: criticalFailure.description,\n        appliedRules: ruleResults\n      };\n    }\n    \n    // Return valid with offline warning\n    return {\n      isValid: true,\n      message: 'Ticket appears valid (offline)',\n      errorType: 'warning',\n      details: 'Limited validation in offline mode. Ticket will be fully validated when connection is restored.',\n      appliedRules: ruleResults\n    };\n    \n  } catch (error) {\n    console.error('Offline ticket validation error:', error);\n    return {\n      isValid: false,\n      message: 'Error validating ticket',\n      errorType: 'error',\n      details: error.message\n    };\n  }\n};\n\n/**\n * Mark a ticket as used/scanned\n * @param {string} ticketId - The ticket ID\n * @param {string} eventId - The event ID\n * @param {string} gateId - The gate ID where ticket was scanned\n * @returns {Promise<object>} - Result of the operation\n */\nexport const markTicketAsUsed = async (ticketId, eventId, gateId) => {\n  // Simulate network request\n  await new Promise(resolve => setTimeout(resolve, 800));\n  \n  // In a real app, this would update the ticket status on the server\n  return {\n    success: true,\n    timestamp: new Date().toISOString()\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}